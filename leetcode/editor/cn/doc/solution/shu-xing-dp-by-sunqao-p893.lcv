是这道题目的变形[543. 二叉树的直径](/problems/diameter-of-binary-tree/)

## 解题思路

结点`i`有两个角色
`f[i][0]`表示以结点`i`为根节点的路径的和的最大值，也就是经过结点`i`分叉的最大路径和
`f[i][1]`表示结点`i`对经过经过这个结点的路径的最大贡献值，也就是对经过结点`i`不分叉，直接向上走的路径的最大贡献值，也就是在以结点`i`作为根节点的这颗子树中，从结点`i`出发，径直向下的路径最大值
可以得到递推公式：
1. `f[i][0] = max(f[l][1], 0) +max(f[r][1], 0) + i->val`
2. `f[i][1] = max(max(f[l][1], f[r][1]), 0) + i->val`，对于每个结点，返回给上一层的最大贡献一定是其左右儿子的最大非零贡献加上自己结点的值

如果以集合论的角度来理解第二点的话，就是一个结点`i`向下延申的最大值可以分为三类
1. 向左儿子延申, 即：`f[i][1] = i->val + f[l][1]`，如果向左儿子延申，那么延申最大值一定是当前结点加上左儿子向下延申的最大值
2. 向右儿子延申, 即：`f[i][1] = i->val + f[r][1]`，如果向右儿子延申，那么延申最大值一定是当前结点加上右儿子向下延申的最大值
3. 不延伸, 即：`f[i][1] = i->val`
三者取大就是`f[i][1]`代表的值：`f[i][1] = max(i->val + f[l][1], i->val + f[r][1], i->val)`，与上面的第二个递推等价

注意如果`f[i][1]`是一个负数，则它对总路径的贡献要替换成`0`
结果只可能出现在以这个结点为根节点的路径中

### 代码

* cpp

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxSum = INT_MIN;
    //这个函数用来求每个结点对经过它径直向上的路径的最大贡献
    //在求最大贡献的时候算出以每个结点为根节点的路径的最大值
    int dfs(TreeNode* root)
    {
        if(!root) return 0;
        //求左儿子的贡献
        int leftSum = dfs(root->left);
        //求右儿子的贡献
        int rightSum = dfs(root->right);
        //结果只可能出现在以这个结点为根节点的路径中
        maxSum = max(max(leftSum, 0) + max(rightSum, 0) + root->val, maxSum);
        //返回当前结点对路径的贡献
        return max(max(leftSum, rightSum), 0) + root->val;
        //return max(max(root->val + leftSum, root->val + rightSum), root->val)
    }
    int maxPathSum(TreeNode* root) {
        dfs(root);
        return maxSum;
    }
};
```

