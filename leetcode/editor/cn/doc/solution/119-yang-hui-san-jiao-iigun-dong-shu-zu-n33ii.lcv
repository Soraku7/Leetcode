### 解题思路

按照动态规划的思想，应该创建一个 n x n（`n = rowIndex + 1`）的二维数组，然后从第三行起逐行填空，返回最后一行。实际操作中没必要创建严格的方阵，用一个下三角矩阵就够了，这样可以省一半的空间。
![2022-01-06_18-37-21.jpg](https://pic.leetcode-cn.com/1641465452-zBoYws-2022-01-06_18-37-21.jpg)

### 代码

* []

```C++
class Solution {
public:
	vector< int > getRow( int rowIndex )
	{
		int n = rowIndex + 1;
		vector< vector< int > > mat{ { 1 }, { 1, 1 } };

		for( int i = 2; i < n; ++i )
		{
			vector< int > &prev = mat[ i - 1 ], row( i + 1, 1 );
			for( int j = 1; j < i; ++j )
				row[ j ] = prev[ j - 1 ] + prev[ j ];
			mat.emplace_back( std::move( row ) );
		}

		return std::move( mat[ rowIndex ] );
	}
};
```

### 代码优化：滚动数组

通过观察，可知每一行仅与前一行相关，再前面已经没用了。所以我们只需要预备一个足够长（n）的一维数组，把它看做当前待填写的行，而它的前n - 1个元素可以看做是前一行。这里有一个小技巧，就是每一行倒着从后往前填，这样每覆盖填写一个数就不会影响下一项的计算。

以第五行为例，初始状态为第4行填写完的结果[1,3,3,1,1]，从倒数第二个格子开始计算（首尾两格是边界不用管）：
![2022-01-06_18-58-41.jpg](https://pic.leetcode-cn.com/1641466747-iegvaG-2022-01-06_18-58-41.jpg)

采用这种滚动数组的思想，重复利用已有的空间，时间复杂度是一样的，但可以大大节省空间复杂度。

### 代码

* []

```C++
class Solution {
public:
	vector< int > getRow( int rowIndex )
	{
		vector< int > row( ++rowIndex, 1 );	// 值初始化为1
		for( int i = 2; i < rowIndex; ++i )	// 从第三行开始算
			for( int j = i - 1; j > 0; --j )// 首尾两格不动
				row[ j ] += row[ j - 1 ];	// row[ j ] = row[ j - 1 ] + row[ j ]的简写

		return row;
	}
};
```

