* 

```
//常规dfs不行的原因是每层递归会去匹配s和t的每个下标是否相等 比如s[i]与t[j]
//若s[i]==t[j] 有配对或者不配对两个递归分支 每个递归分支又有更多的递归分支
//那么不可避免的 会有很多的重复计算
//为了避免重复计算 可以使用记忆化搜索 把已经搜索过的下标[i,j]的结果保存起来
//这样就节省了很多不必要的开销 使用unordered_map<pair<int>,int>来保存记忆数组最合适
//但是C++中没有给pair做Hash的函数，所以不能用pair作为unordered_map的key。
//但是,map里面是通过操作符<来比较大小，而pair是可以比较大小的。所以可以用map
map<pair<int,int>,int> my_map;
int dfs_memory(string &s, string &t,int i, int j){
    if( my_map.count({i,j})!=0)  return my_map[{i,j}];
    if(s.size()-i<t.size()-j) return 0;//已无法配对 剪枝
    if(j==t.size()) return 1;//配对完成 数量+1
    int cnt=0;
    cnt+=dfs_memory(s,t,i+1,j);//不匹配的情况
    if(s[i]==t[j])  cnt+=dfs_memory(s,t,i+1,j+1);
    my_map[{i,j}]=cnt;
    return cnt;
}

int numDistinct(string s, string t) {
    return dfs_memory(s,t,0,0);
}
```

